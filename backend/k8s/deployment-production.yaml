---
# Deployment manifest for GitHub Actions (production-ready)
# Uses image from GitHub Container Registry

apiVersion: v1
kind: Namespace
metadata:
  name: demo-app

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: demo-app
  namespace: demo-app

---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: demo-app
  namespace: demo-app
rules:
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list", "watch"]
  - apiGroups: [""]
    resources: ["configmaps"]
    verbs: ["get"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: demo-app
  namespace: demo-app
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: demo-app
subjects:
  - kind: ServiceAccount
    name: demo-app
    namespace: demo-app

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
  namespace: demo-app
data:
  APP_VERSION: "1.0.0"
  ENVIRONMENT: "production"
  REDIS_URL: "redis://demo-redis.demo-app.svc.cluster.local:6379/0"
  LOG_LEVEL: "INFO"

---
apiVersion: v1
kind: Service
metadata:
  name: demo-app
  namespace: demo-app
  labels:
    app: demo-app
spec:
  type: ClusterIP
  selector:
    app: demo-app
  ports:
    - name: http
      protocol: TCP
      port: 80
      targetPort: 5000

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: demo-app
  namespace: demo-app
  labels:
    app: demo-app
    version: v1
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1  # Максимум 1 новый под сверх желаемого количества
      maxUnavailable: 0  # Не допускаем недоступных подов во время обновления (для стабильности)
  revisionHistoryLimit: 3  # Ограничиваем историю ревизий
  selector:
    matchLabels:
      app: demo-app
  template:
    metadata:
      labels:
        app: demo-app
        version: v1
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "5000"
        prometheus.io/path: "/metrics"
        deployment.kubernetes.io/revision: "auto"
    spec:
      tolerations:
        - key: node-role.kubernetes.io/master
          operator: Exists
          effect: NoSchedule
      
      serviceAccountName: demo-app
      
      # InitContainer для ожидания готовности Redis и PostgreSQL
      initContainers:
        - name: wait-for-redis
          image: busybox:1.36
          command: ['sh', '-c']
          args:
            - |
              set -e
              echo "Waiting for Redis to be ready at demo-redis.demo-app.svc.cluster.local:6379..."
              COUNTER=0
              MAX_ATTEMPTS=90  # Увеличиваем до 90 попыток (3 минуты)
              while ! nc -z -w 2 demo-redis.demo-app.svc.cluster.local 6379 2>/dev/null; do
                COUNTER=$((COUNTER + 1))
                if [ $COUNTER -ge $MAX_ATTEMPTS ]; then
                  echo "❌ Redis connection timeout after $MAX_ATTEMPTS attempts"
                  echo "Debug: Trying DNS resolution..."
                  nslookup demo-redis.demo-app.svc.cluster.local || echo "DNS lookup failed"
                  exit 1
                fi
                if [ $((COUNTER % 5)) -eq 0 ]; then
                  echo "Redis not ready, waiting... (attempt $COUNTER/$MAX_ATTEMPTS)"
                fi
                sleep 2
              done
              echo "✅ Redis is ready! (attempt $COUNTER/$MAX_ATTEMPTS)"
          resources:
            requests:
              cpu: 10m
              memory: 16Mi
            limits:
              cpu: 50m
              memory: 32Mi
        
        - name: wait-for-postgres
          image: busybox:1.36
          command: ['sh', '-c']
          args:
            - |
              set -e
              echo "Waiting for PostgreSQL to be ready at postgres.demo-app.svc.cluster.local:5432..."
              COUNTER=0
              MAX_ATTEMPTS=90  # Увеличиваем до 90 попыток (3 минуты)
              while ! nc -z -w 2 postgres.demo-app.svc.cluster.local 5432 2>/dev/null; do
                COUNTER=$((COUNTER + 1))
                if [ $COUNTER -ge $MAX_ATTEMPTS ]; then
                  echo "❌ PostgreSQL connection timeout after $MAX_ATTEMPTS attempts"
                  echo "Debug: Trying DNS resolution..."
                  nslookup postgres.demo-app.svc.cluster.local || echo "DNS lookup failed"
                  exit 1
                fi
                if [ $((COUNTER % 5)) -eq 0 ]; then
                  echo "PostgreSQL not ready, waiting... (attempt $COUNTER/$MAX_ATTEMPTS)"
                fi
                sleep 2
              done
              echo "✅ PostgreSQL is ready! (attempt $COUNTER/$MAX_ATTEMPTS)"
          resources:
            requests:
              cpu: 10m
              memory: 16Mi
            limits:
              cpu: 50m
              memory: 32Mi
      
      containers:
        - name: app
          # Используем образ из GitHub Container Registry
          # В CI/CD пайплайне это будет заменено на реальный образ с SHA тегом
          image: IMAGE_REGISTRY/IMAGE_NAME:IMAGE_TAG
          imagePullPolicy: Always
          
          workingDir: /app
          
          command: ["/app/.venv/bin/gunicorn"]
          args: ["--bind", "0.0.0.0:5000", "--workers", "4", "--worker-class", "sync", "--timeout", "30", "--access-logfile", "-", "--error-logfile", "-", "src.app:app"]
          
          ports:
            - name: http
              containerPort: 5000
              protocol: TCP
          
          env:
            - name: HOSTNAME
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
            - name: POD_IP
              valueFrom:
                fieldRef:
                  fieldPath: status.podIP
          envFrom:
            - configMapRef:
                name: app-config
          
          resources:
            requests:
              cpu: 150m  # Уменьшаем requests для лучшей доступности ресурсов
              memory: 256Mi
            limits:
              cpu: 1000m
              memory: 1Gi
          
          livenessProbe:
            httpGet:
              path: /api/health
              port: http
            initialDelaySeconds: 10
            periodSeconds: 10
            timeoutSeconds: 3
            failureThreshold: 3
          
          readinessProbe:
            httpGet:
              path: /api/health
              port: http
            initialDelaySeconds: 10
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
          
          startupProbe:
            httpGet:
              path: /api/health
              port: http
            initialDelaySeconds: 15  # Увеличиваем начальную задержку
            periodSeconds: 10  # Проверяем реже (каждые 10 сек)
            timeoutSeconds: 5  # Таймаут на ответ
            failureThreshold: 30  # До 30 попыток (5 минут максимум)
          
          securityContext:
            allowPrivilegeEscalation: false
            runAsNonRoot: true
            runAsUser: 1000
            readOnlyRootFilesystem: false
          
          volumeMounts:
            - name: tmp
              mountPath: /tmp
      
      volumes:
        - name: tmp
          emptyDir: {}

---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: demo-app-hpa
  namespace: demo-app
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: demo-app
  minReplicas: 3
  maxReplicas: 10
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 80
